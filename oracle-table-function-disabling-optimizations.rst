Oracle table() function disabling optimizations
===============================================

:Abstract: Including table() function anywhere in a query in Oracle database disables some optimizations.
:Authors: Jyri-Matti Lähteenmäki
:Date: 2024-06-02
:Status: Draft


I'm working in a project using Oracle database where we have many complex views and sometimes need separate functions to calculate things. We noticed that including ``table()`` function anywhere in a query disables some of Oracle's optimizations.

The examples in this blog have been tested using Oracle 19c.

Creating test data
------------------

Let's create some test data, using a million rows to ensure we get realistic plans.

.. code:: sql

    CREATE TABLE department (
	  depid NUMBER,
	  depname VARCHAR2(30),
	  PRIMARY KEY (depid)
	);

	CREATE TABLE employee (
	  empid NUMBER GENERATED BY DEFAULT AS IDENTITY,
	  depid NUMBER,
	  PRIMARY KEY (empid),
	  FOREIGN KEY(depid) REFERENCES department(depid)
	);

	CREATE INDEX depname_idx ON department(depname);
	CREATE INDEX dep_idx ON employee(depid);
	
	BEGIN
	  FOR i IN 1..1000 LOOP
	    INSERT INTO department(depid, depname) VALUES (i, 'department-'||i);
	    
	    FOR j IN 1..1000 LOOP
	      INSERT INTO employee(depid) VALUES (i);
	    END LOOP;
	  END LOOP;
	  COMMIT;
	END;
	/
	
	CALL DBMS_STATS.GATHER_TABLE_STATS(user, 'department');
	CALL DBMS_STATS.GATHER_TABLE_STATS(user, 'employee');

Trying different queries
------------------------

Let's first try with a simple join:

.. code:: sql

	SELECT /*+ GATHER_PLAN_STATISTICS */ count(empid)
	FROM department d
	JOIN employee e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));
	
	---------------------------------------------------------------------------------------------------------------
	| Id  | Operation                             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
	---------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                      |             |      1 |        |      1 |00:00:00.01 |       7 |
	|   1 |  SORT AGGREGATE                       |             |      1 |      1 |      1 |00:00:00.01 |       7 |
	|   2 |   NESTED LOOPS                        |             |      1 |   1000 |   1000 |00:00:00.01 |       7 |
	|   3 |    TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT  |      1 |      1 |      1 |00:00:00.01 |       3 |
	|*  4 |     INDEX RANGE SCAN                  | DEPNAME_IDX |      1 |      1 |      1 |00:00:00.01 |       2 |
	|*  5 |    INDEX RANGE SCAN                   | DEP_IDX     |      1 |   1000 |   1000 |00:00:00.01 |       4 |
	---------------------------------------------------------------------------------------------------------------
	
The plan is as expected, the predicate is used for an `index access path<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6>`__ to the first table, and the result is joined to the second table again using an index access path.

The same happens when using views, where the (here inline) views are `merged<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD>`__ into the above query:

.. code:: sql

	SELECT /*+ GATHER_PLAN_STATISTICS */ count(empid)
	FROM (SELECT * FROM department) d
	JOIN (SELECT * FROM employee) e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));

	---------------------------------------------------------------------------------------------------------------
	| Id  | Operation                             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
	---------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                      |             |      1 |        |      1 |00:00:00.01 |       7 |
	|   1 |  SORT AGGREGATE                       |             |      1 |      1 |      1 |00:00:00.01 |       7 |
	|   2 |   NESTED LOOPS                        |             |      1 |   1000 |   1000 |00:00:00.01 |       7 |
	|   3 |    TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT  |      1 |      1 |      1 |00:00:00.01 |       3 |
	|*  4 |     INDEX RANGE SCAN                  | DEPNAME_IDX |      1 |      1 |      1 |00:00:00.01 |       2 |
	|*  5 |    INDEX RANGE SCAN                   | DEP_IDX     |      1 |   1000 |   1000 |00:00:00.01 |       4 |
	---------------------------------------------------------------------------------------------------------------

Sometimes queries get more complex and the views become unmergeable. In this case I've made the views unmergeable by using a ``GROUP BY``:

.. code:: sql

	SELECT /*+ GATHER_PLAN_STATISTICS */ emps
	FROM (SELECT depid, depname FROM department GROUP BY depid, depname) d
	JOIN (SELECT depid, count(*) emps FROM employee GROUP BY depid) e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));
	
	--------------------------------------------------------------------------------------------------------------
	| Id  | Operation                            | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
	--------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                     |             |      1 |        |      1 |00:00:00.01 |       7 |
	|   1 |  NESTED LOOPS                        |             |      1 |      1 |      1 |00:00:00.01 |       7 |
	|   2 |   TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT  |      1 |      1 |      1 |00:00:00.01 |       3 |
	|*  3 |    INDEX RANGE SCAN                  | DEPNAME_IDX |      1 |      1 |      1 |00:00:00.01 |       2 |
	|   4 |   VIEW PUSHED PREDICATE              |             |      1 |      1 |      1 |00:00:00.01 |       4 |
	|*  5 |    FILTER                            |             |      1 |        |      1 |00:00:00.01 |       4 |
	|   6 |     SORT AGGREGATE                   |             |      1 |      1 |      1 |00:00:00.01 |       4 |
	|*  7 |      INDEX RANGE SCAN                | DEP_IDX     |      1 |   1000 |   1000 |00:00:00.01 |       4 |
	--------------------------------------------------------------------------------------------------------------

The plan is still great and we can see Oracle using a `join-predicate push-down<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/query-transformations.html#GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709>`__ (``VIEW PUSHED PREDICATE``) with `nested looping<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/joins.html#TGSQL-GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53>`__ to push the predicate resulted from the first view into the second view. This example is quite artificial but in real life I've seen this sort of thing happening all the time.

Now, let's see what happens when we make a trivial change of using a function returning `multiple values<https://docs.oracle.com/en/database/oracle/oracle-database/23/lnpls/plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C>`__:

.. code:: sql

	CREATE FUNCTION repeat_value(p_value IN NUMBER, p_amount IN NUMBER) RETURN SYS.ODCINUMBERLIST AS
	  m_ret SYS.ODCINUMBERLIST := SYS.ODCINUMBERLIST();
	BEGIN
	    FOR i IN 1..p_amount LOOP
	        m_ret.EXTEND;
	        m_ret(m_ret.COUNT) := p_value;
	    END LOOP;
	    RETURN m_ret;
	END;
	/
	
	SELECT /*+ GATHER_PLAN_STATISTICS */ (SELECT count(*) FROM table(repeat_value(1, emps)))
	FROM (SELECT depid, depname FROM department GROUP BY depid, depname) d
	JOIN (SELECT depid, count(*) emps FROM employee GROUP BY depid) e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));
	
	---------------------------------------------------------------------------------------------------------------------------------------------
	| Id  | Operation                               | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
	---------------------------------------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                        |              |      1 |        |      1 |00:00:00.11 |    1831 |       |       |          |
	|   1 |  SORT AGGREGATE                         |              |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|   2 |   COLLECTION ITERATOR PICKLER FETCH     | REPEAT_VALUE |      1 |   8168 |  10000 |00:00:00.01 |       0 |       |       |          |
	|*  3 |  HASH JOIN                              |              |      1 |      1 |      1 |00:00:00.11 |    1831 |  2546K|  2546K|  289K (0)|
	|   4 |   JOIN FILTER CREATE                    | :BF0000      |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|   5 |    VIEW                                 |              |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|   6 |     HASH GROUP BY                       |              |      1 |      1 |      1 |00:00:00.01 |       2 |  1422K|  1422K|  530K (0)|
	|*  7 |      TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT   |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|   8 |       INDEX FULL SCAN                   | SYS_C0038872 |      1 |    100 |    100 |00:00:00.01 |       1 |       |       |          |
	|   9 |   VIEW                                  |              |      1 |    100 |    100 |00:00:00.11 |    1829 |       |       |          |
	|  10 |    HASH GROUP BY                        |              |      1 |    100 |    100 |00:00:00.11 |    1829 |  1558K|  1558K| 1429K (0)|
	|  11 |     JOIN FILTER USE                     | :BF0000      |      1 |   1000K|   1000K|00:00:00.16 |    1829 |       |       |          |
	|* 12 |      TABLE ACCESS FULL                  | EMPLOYEE     |      1 |   1000K|   1000K|00:00:00.07 |    1829 |       |       |          |
	---------------------------------------------------------------------------------------------------------------------------------------------

The plan is suddenly a lot slower. Oracle has switched into a `hash join<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB>`__ for some reason. Let's investigate by forcing it back into a nested loop with a `hint<https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/Comments.html#GUID-D316D545-89E2-4D54-977F-FC97815CD62E>`__:

.. code:: sql

	SELECT /*+ GATHER_PLAN_STATISTICS USE_NL(d e) */ (SELECT count(*) FROM table(repeat_value(1, emps)))
	FROM (SELECT depid, depname FROM department GROUP BY depid, depname) d
	JOIN (SELECT depid, count(*) emps FROM employee GROUP BY depid) e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));
	
	--------------------------------------------------------------------------------------------------------------------------------------------
	| Id  | Operation                              | Name         | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
	--------------------------------------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                       |              |      1 |        |      1 |00:00:00.11 |    1831 |       |       |          |
	|   1 |  SORT AGGREGATE                        |              |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|   2 |   COLLECTION ITERATOR PICKLER FETCH    | REPEAT_VALUE |      1 |   8168 |  10000 |00:00:00.01 |       0 |       |       |          |
	|   3 |  NESTED LOOPS                          |              |      1 |      1 |      1 |00:00:00.11 |    1831 |       |       |          |
	|   4 |   VIEW                                 |              |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|   5 |    HASH GROUP BY                       |              |      1 |      1 |      1 |00:00:00.01 |       2 |  1422K|  1422K|  532K (0)|
	|*  6 |     TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT   |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|   7 |      INDEX FULL SCAN                   | SYS_C0038872 |      1 |    100 |    100 |00:00:00.01 |       1 |       |       |          |
	|*  8 |   VIEW                                 |              |      1 |      1 |      1 |00:00:00.11 |    1829 |       |       |          |
	|   9 |    SORT GROUP BY                       |              |      1 |    100 |    100 |00:00:00.11 |    1829 |  6144 |  6144 | 6144  (0)|
	|  10 |     TABLE ACCESS FULL                  | EMPLOYEE     |      1 |   1000K|   1000K|00:00:00.01 |    1829 |       |       |          |
	--------------------------------------------------------------------------------------------------------------------------------------------

Turns out Oracle is using `full scans<https://docs.oracle.com/en/database/oracle/oracle-database/23/tgsql/optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B>`__ instead of index access, which is probably why it decided to go with a hash join instead. But why? By just adding an innocent function call, our plan seems to have lost its ability to push predicates into views!

There's a support case `Table Function Disables Push Predicate Query Transformation (Doc ID 3003810.1)<https://support.oracle.com/epmos/faces/DocumentDisplay?id=3003810.1>`__ about this, which says:

	Cause: CBQT (Cost Based Query Transformation) is disabled by design because the TABLE() Function is included in the query

	Solution: Re-write the query without the TABLE() Function.

So, whenever we need to add ``table()`` function for whatever reason, some important optimizations are disabled. Sometimes you can leave out the table-wrapper, but that's just syntactic sugar and doesn't change anything. Unfortunately ``table()`` function is needed for various cases:

- use a function returning a varray/table/pipelined-table
- use `polymorphic table functions<https://blog.lahteenmaki.net/brief-intro-to-oracle-macros-etc.html>`__
- access rows from a nested table: ``SELECT * FROM department, table(department.someNestedTable);``
- replace varying length IN-lists with an array to reduce hard parsing: ``SELECT * FROM department WHERE depname IN (SELECT * FROM table(:1));``
- something else?

Workaround
----------

Luckily, at least for using functions, there's a workaround!

Instead of returning multiple values from a function, return them as a ``VARCHAR``. This doesn't work for complex data, but it's usable for things representable as simple strings:

.. code:: sql

	CREATE FUNCTION repeat_value_str(p_value IN NUMBER, p_amount IN NUMBER) RETURN VARCHAR2 AS
	  m_ret VARCHAR2(32767);
	BEGIN
	    FOR i IN 1..p_amount-1 LOOP
	        m_ret := m_ret||p_value;
	        m_ret := m_ret||'_';
	    END LOOP;
	    m_ret := m_ret||p_value;
	    RETURN m_ret;
	END;
	/
	
Then use `regular expressions<https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/REGEXP_SUBSTR.html>`__ to split the string into a ``UNION ALL`` one value at a time. This only works if you know the maximum possible amount of values, and there can't be hundreds of them. In this case I've added support for max 5 values, which obviously is not enough for our 10000 employee departments:

.. code:: sql

	SELECT /*+ GATHER_PLAN_STATISTICS USE_NL(d e) */ (
	    SELECT count(*)
	    FROM (SELECT a, regexp_count(a, '[^_]+') b FROM (SELECT /*+ NO_MERGE */ repeat_value_str(1, LEAST(emps, 5)) a FROM DUAL)) foo,
	    LATERAL (SELECT regexp_substr(a, '[^_]+', 1, 1) c  FROM DUAL WHERE b >= 1 UNION ALL
	             SELECT regexp_substr(a, '[^_]+', 1, 2) c  FROM DUAL WHERE b >= 2 UNION ALL
	             SELECT regexp_substr(a, '[^_]+', 1, 3) c  FROM DUAL WHERE b >= 3 UNION ALL
	             SELECT regexp_substr(a, '[^_]+', 1, 4) c  FROM DUAL WHERE b >= 4 UNION ALL
	             SELECT regexp_substr(a, '[^_]+', 1, 5) c  FROM DUAL WHERE b >= 5
	              AND 1 = CASE WHEN b <= 5 THEN 1 ELSE to_number('a') END)
	    WHERE c IS NOT NULL
	)
	FROM (SELECT depid, depname FROM department GROUP BY depid, depname) d
	JOIN (SELECT depid, count(*) emps FROM employee GROUP BY depid) e ON e.depid = d.depid
	WHERE depname = 'department-1';
	
	SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(format => 'allstats last'));

If we look at the plan, it's back into pushing down predicates. Note that the ``NO_MERGE`` hint is required since otherwise Oracle tends to inline the function invocation into all branches of the union, which would destroy performance with any non-trivial function.

.. code:: sql

	-----------------------------------------------------------------------------------------------------------------------------------------------
	| Id  | Operation                              | Name            | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |
	-----------------------------------------------------------------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT                       |                 |      1 |        |      1 |00:00:00.01 |      28 |       |       |          |
	|   1 |  SORT AGGREGATE                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|   2 |   NESTED LOOPS                         |                 |      1 |      5 |      5 |00:00:00.01 |       0 |       |       |          |
	|   3 |    VIEW                                |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|   4 |     FAST DUAL                          |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|   5 |    VIEW                                | VW_LAT_33CB5887 |      1 |      5 |      5 |00:00:00.01 |       0 |       |       |          |
	|   6 |     UNION-ALL                          |                 |      1 |        |      5 |00:00:00.01 |       0 |       |       |          |
	|*  7 |      FILTER                            |                 |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |
	|   8 |       FAST DUAL                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|*  9 |      FILTER                            |                 |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |
	|  10 |       FAST DUAL                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|* 11 |      FILTER                            |                 |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |
	|  12 |       FAST DUAL                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|* 13 |      FILTER                            |                 |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |
	|  14 |       FAST DUAL                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|* 15 |      FILTER                            |                 |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |
	|  16 |       FAST DUAL                        |                 |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |
	|  17 |  NESTED LOOPS                          |                 |      1 |      1 |      1 |00:00:00.01 |      28 |       |       |          |
	|  18 |   VIEW                                 |                 |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|  19 |    HASH GROUP BY                       |                 |      1 |      1 |      1 |00:00:00.01 |       2 |  1422K|  1422K|  493K (0)|
	|* 20 |     TABLE ACCESS BY INDEX ROWID BATCHED| DEPARTMENT      |      1 |      1 |      1 |00:00:00.01 |       2 |       |       |          |
	|  21 |      INDEX FULL SCAN                   | SYS_C0038872    |      1 |    100 |    100 |00:00:00.01 |       1 |       |       |          |
	|  22 |   VIEW PUSHED PREDICATE                |                 |      1 |      1 |      1 |00:00:00.01 |      26 |       |       |          |
	|* 23 |    FILTER                              |                 |      1 |        |      1 |00:00:00.01 |      26 |       |       |          |
	|  24 |     SORT AGGREGATE                     |                 |      1 |      1 |      1 |00:00:00.01 |      26 |       |       |          |
	|* 25 |      INDEX RANGE SCAN                  | DEP_IDX         |      1 |  10000 |  10000 |00:00:00.01 |      26 |       |       |          |
	-----------------------------------------------------------------------------------------------------------------------------------------------

As a side note: notice that Oracle is still performing a full index scan for department table. I don't know why, but an index scan can be forced with a hint ``INDEX(d depname_idx)``.

Summary
-------

Oracle disables some optimizations like join predicate pushdown whenever a ``table()`` function is present anywhere in the parsed query structure. There are ways to rewrite queries to not use table function, but sometimes it gets difficult. I hope Oracle will consider this design choice in some future database version, since for many cases it might be quite a `silver bullet<https://en.wikipedia.org/wiki/Silver_bullet>`__.
